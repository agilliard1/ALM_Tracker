"""
ALM Meta Data Manager (SQLite + Tkinter)
-------------------------------------------

Features
- Keeps an append-only audit log of records in SQLite.
- Each save creates a NEW row with timestamp + Windows user id (no in-place edits).
- GUI editor for the current (latest) version of any ID (fields are free-form JSON).
- View list of all IDs with their most up-to-date data.
- Export only the most current snapshot (one row per ID) to CSV.
- Export the full audit log (every version) to CSV.

Assumptions
- Your record "fields" are stored as a JSON object (key → value). This keeps the
  schema flexible without changing the DB when fields evolve.
- The audit metadata columns (updated_at, updated_by) are generated by the app and
  are not editable.

How to run
  python alm_meta_data_tracker.py

A SQLite DB file named `records.sqlite3` will be created in the same folder on first run.

Notes
- Time is stored in ISO 8601 UTC for stable ordering.
- JSON must be a single JSON object (e.g., {"name": "Alice", "qty": 10}).
- When exporting to CSV, JSON fields are flattened one level (top-level keys only).
"""
from __future__ import annotations

import csv
import json
import os
import sqlite3
import sys
import getpass
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List, Tuple, Any

import tkinter as tk
from tkinter import ttk, messagebox, filedialog, simpledialog

# ---------------------------
# Config
# ---------------------------
DB_FILENAME = "records.sqlite3"
APP_TITLE = "ALM Meta Data Manager"

# ---------------------------
# Database helpers
# ---------------------------

def get_db_path() -> Path:
    return Path(__file__).with_name(DB_FILENAME)


def connect_db(db_path: Path) -> sqlite3.Connection:
    conn = sqlite3.connect(str(db_path))
    conn.row_factory = sqlite3.Row
    return conn


def init_db(conn: sqlite3.Connection) -> None:
    cur = conn.cursor()
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS records (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            entity_id TEXT NOT NULL,
            data_json TEXT NOT NULL,
            updated_by TEXT NOT NULL,
            updated_at TEXT NOT NULL
        )
        """
    )
    cur.execute("CREATE INDEX IF NOT EXISTS idx_records_entity ON records(entity_id)")
    cur.execute("CREATE INDEX IF NOT EXISTS idx_records_entity_id ON records(entity_id, id)")
    conn.commit()


def utc_now_iso() -> str:
    return datetime.now(timezone.utc).isoformat(timespec="seconds")


def current_user() -> str:
    # Prefer Windows user if available; fallback to getpass
    return os.environ.get("USERNAME") or getpass.getuser() or "unknown"


def insert_new_version(conn: sqlite3.Connection, entity_id: str, data: Dict[str, Any]) -> int:
    data_json = json.dumps(data, ensure_ascii=False)
    user = current_user()
    ts = utc_now_iso()
    cur = conn.cursor()
    cur.execute(
        "INSERT INTO records(entity_id, data_json, updated_by, updated_at) VALUES (?, ?, ?, ?)",
        (entity_id, data_json, user, ts),
    )
    conn.commit()
    return cur.lastrowid


def get_latest_row(conn: sqlite3.Connection, entity_id: str) -> sqlite3.Row | None:
    cur = conn.cursor()
    cur.execute(
        """
        SELECT r.* FROM records r
        JOIN (
            SELECT entity_id, MAX(id) AS max_id
            FROM records
            WHERE entity_id = ?
        ) latest ON r.entity_id = latest.entity_id AND r.id = latest.max_id
        """,
        (entity_id,),
    )
    return cur.fetchone()


def get_latest_snapshot(conn: sqlite3.Connection) -> List[sqlite3.Row]:
    cur = conn.cursor()
    # Grab the latest id per entity_id and return those rows
    cur.execute(
        """
        SELECT r.* FROM records r
        JOIN (
            SELECT entity_id, MAX(id) AS max_id
            FROM records
            GROUP BY entity_id
        ) latest ON r.entity_id = latest.entity_id AND r.id = latest.max_id
        ORDER BY r.entity_id COLLATE NOCASE
        """
    )
    return cur.fetchall()


def get_all_rows(conn: sqlite3.Connection) -> List[sqlite3.Row]:
    cur = conn.cursor()
    cur.execute("SELECT * FROM records ORDER BY entity_id COLLATE NOCASE, id ASC")
    return cur.fetchall()


def get_all_entity_ids(conn: sqlite3.Connection) -> List[str]:
    cur = conn.cursor()
    cur.execute("SELECT DISTINCT entity_id FROM records ORDER BY entity_id COLLATE NOCASE")
    return [r[0] for r in cur.fetchall()]


def get_history(conn: sqlite3.Connection, entity_id: str) -> List[sqlite3.Row]:
    cur = conn.cursor()
    cur.execute(
        "SELECT * FROM records WHERE entity_id = ? ORDER BY id DESC",
        (entity_id,),
    )
    return cur.fetchall()

# ---------------------------
# CSV helpers
# ---------------------------

def _collect_keys(rows: List[sqlite3.Row]) -> List[str]:
    keys = set()
    for r in rows:
        try:
            d = json.loads(r["data_json"]) if r["data_json"] else {}
            if isinstance(d, dict):
                keys.update(d.keys())
        except Exception:
            # Skip bad JSON; it shouldn't happen as we validate before writing
            pass
    return sorted(keys, key=str.lower)


def export_current_snapshot_csv(conn: sqlite3.Connection, out_path: Path) -> None:
    rows = get_latest_snapshot(conn)
    field_keys = _collect_keys(rows)
    headers = ["entity_id", "updated_at", "updated_by"] + field_keys

    with out_path.open("w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=headers)
        writer.writeheader()
        for r in rows:
            base = {
                "entity_id": r["entity_id"],
                "updated_at": r["updated_at"],
                "updated_by": r["updated_by"],
            }
            data = {}
            try:
                data = json.loads(r["data_json"]) or {}
            except Exception:
                data = {"__error_parsing_json": r["data_json"]}
            row_out = base | {k: data.get(k, "") for k in field_keys}
            writer.writerow(row_out)


def export_full_audit_csv(conn: sqlite3.Connection, out_path: Path) -> None:
    rows = get_all_rows(conn)
    field_keys = _collect_keys(rows)
    headers = ["id", "entity_id", "updated_at", "updated_by"] + field_keys

    with out_path.open("w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=headers)
        writer.writeheader()
        for r in rows:
            base = {
                "id": r["id"],
                "entity_id": r["entity_id"],
                "updated_at": r["updated_at"],
                "updated_by": r["updated_by"],
            }
            try:
                data = json.loads(r["data_json"]) or {}
            except Exception:
                data = {"__error_parsing_json": r["data_json"]}
            row_out = base | {k: data.get(k, "") for k in field_keys}
            writer.writerow(row_out)

# ---------------------------
# GUI
# ---------------------------
class App(tk.Tk):
    def __init__(self, conn: sqlite3.Connection):
        super().__init__()
        self.conn = conn
        self.title(APP_TITLE)
        self.geometry("1100x650")

        self.current_entity: str | None = None
        self.current_loaded_row_id: int | None = None  # id of version currently in editor

        self._build_menu()
        self._build_ui()
        self.refresh_entity_list()

    # ---------- Menu ----------
    def _build_menu(self):
        menubar = tk.Menu(self)

        filemenu = tk.Menu(menubar, tearoff=0)
        filemenu.add_command(label="Export Current Snapshot to CSV...", command=self.on_export_current)
        filemenu.add_command(label="Export Full Audit Log to CSV...", command=self.on_export_full)
        filemenu.add_separator()
        filemenu.add_command(label="Exit", command=self.destroy)
        menubar.add_cascade(label="File", menu=filemenu)

        helpmenu = tk.Menu(menubar, tearoff=0)
        helpmenu.add_command(label="About", command=self.on_about)
        menubar.add_cascade(label="Help", menu=helpmenu)

        self.config(menu=menubar)

    # ---------- Layout ----------
    def _build_ui(self):
        root = ttk.Frame(self)
        root.pack(fill=tk.BOTH, expand=True)

        # Left panel: entity list + search + buttons
        left = ttk.Frame(root, padding=(8, 8))
        left.pack(side=tk.LEFT, fill=tk.Y)

        ttk.Label(left, text="Search IDs").pack(anchor=tk.W)
        self.search_var = tk.StringVar()
        self.search_var.trace_add("write", lambda *_: self.refresh_entity_list())
        ttk.Entry(left, textvariable=self.search_var, width=30).pack(anchor=tk.W, pady=(0, 8))

        self.entity_list = tk.Listbox(left, width=30, height=28)
        self.entity_list.pack(fill=tk.Y, expand=False)
        self.entity_list.bind("<<ListboxSelect>>", self.on_select_entity)

        btns = ttk.Frame(left)
        btns.pack(fill=tk.X, pady=8)
        ttk.Button(btns, text="New ID", command=self.on_new_entity).pack(side=tk.LEFT)
        ttk.Button(btns, text="Current View", command=self.show_current_view).pack(side=tk.LEFT, padx=6)
        ttk.Button(btns, text="History", command=self.on_show_history).pack(side=tk.LEFT)

        # Right panel: editor + meta + actions
        right = ttk.Frame(root, padding=(8, 8))
        right.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        meta = ttk.Frame(right)
        meta.pack(fill=tk.X)
        self.meta_entity = ttk.Label(meta, text="ID: –", font=("TkDefaultFont", 10, "bold"))
        self.meta_entity.grid(row=0, column=0, sticky=tk.W, padx=(0, 12))
        self.meta_updated = ttk.Label(meta, text="Updated at: –")
        self.meta_updated.grid(row=0, column=1, sticky=tk.W, padx=(0, 12))
        self.meta_user = ttk.Label(meta, text="Updated by: –")
        self.meta_user.grid(row=0, column=2, sticky=tk.W)

        # JSON editor
        editor_frame = ttk.Frame(right)
        editor_frame.pack(fill=tk.BOTH, expand=True, pady=(8, 4))
        self.editor = tk.Text(editor_frame, wrap=tk.NONE, undo=True)
        self.editor.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        yscroll = ttk.Scrollbar(editor_frame, orient=tk.VERTICAL, command=self.editor.yview)
        yscroll.pack(side=tk.RIGHT, fill=tk.Y)
        self.editor.configure(yscrollcommand=yscroll.set)

        # Action buttons
        actions = ttk.Frame(right)
        actions.pack(fill=tk.X, pady=(6, 0))
        ttk.Button(actions, text="Save New Version", command=self.on_save).pack(side=tk.LEFT)
        ttk.Button(actions, text="Reload Latest", command=self.reload_latest).pack(side=tk.LEFT, padx=6)
        ttk.Button(actions, text="Load from JSON File...", command=self.on_load_json_file).pack(side=tk.LEFT, padx=6)
        ttk.Button(actions, text="Save JSON to File...", command=self.on_save_json_file).pack(side=tk.LEFT)

        # Status bar
        self.status = ttk.Label(self, text="Ready", anchor=tk.W, relief=tk.SUNKEN)
        self.status.pack(side=tk.BOTTOM, fill=tk.X)

    # ---------- Events ----------
    def on_about(self):
        messagebox.showinfo(
            APP_TITLE,
            "Append-only audit logger for arbitrary record data.\n"
            "Edit JSON fields, and each save creates a new row with timestamp and user.",
        )

    def on_new_entity(self):
        new_id = simpledialog.askstring(APP_TITLE, "Enter new ID")
        if not new_id:
            return
        self.current_entity = new_id.strip()
        self.current_loaded_row_id = None
        self.meta_entity.config(text=f"ID: {self.current_entity}")
        self.meta_updated.config(text="Updated at: –")
        self.meta_user.config(text="Updated by: –")
        self.editor.delete("1.0", tk.END)
        self.editor.insert("1.0", "{\n  \"example_field\": \"value\"\n}")
        self.status.config(text=f"Created new ID context '{self.current_entity}'. Edit JSON and click 'Save New Version'.")
        self.refresh_entity_list(select_id=self.current_entity)

    def on_select_entity(self, _event=None):
        sel = self.entity_list.curselection()
        if not sel:
            return
        idx = sel[0]
        entity_id = self.entity_list.get(idx)
        self.load_latest(entity_id)

    def on_save(self):
        if not self.current_entity:
            messagebox.showwarning(APP_TITLE, "Select or create an ID first.")
            return
        txt = self.editor.get("1.0", tk.END).strip()
        if not txt:
            messagebox.showwarning(APP_TITLE, "JSON cannot be empty.")
            return
        try:
            data = json.loads(txt)
        except json.JSONDecodeError as e:
            messagebox.showerror(APP_TITLE, f"Invalid JSON: {e}")
            return
        if not isinstance(data, dict):
            messagebox.showerror(APP_TITLE, "Top-level JSON must be an object (e.g., {\"k\":\"v\"}).")
            return
        rid = insert_new_version(self.conn, self.current_entity, data)
        self.current_loaded_row_id = rid
        self.status.config(text=f"Saved new version for '{self.current_entity}' (row id {rid}).")
        self.load_latest(self.current_entity)
        self.refresh_entity_list(select_id=self.current_entity)

    def reload_latest(self):
        if not self.current_entity:
            return
        self.load_latest(self.current_entity)

    def load_latest(self, entity_id: str):
        row = get_latest_row(self.conn, entity_id)
        self.current_entity = entity_id
        self.meta_entity.config(text=f"ID: {entity_id}")
        if row is None:
            self.editor.delete("1.0", tk.END)
            self.editor.insert("1.0", "{}")
            self.meta_updated.config(text="Updated at: –")
            self.meta_user.config(text="Updated by: –")
            self.current_loaded_row_id = None
            return
        self.current_loaded_row_id = row["id"]
        try:
            pretty = json.dumps(json.loads(row["data_json"]), indent=2, ensure_ascii=False)
        except Exception:
            pretty = row["data_json"]
        self.editor.delete("1.0", tk.END)
        self.editor.insert("1.0", pretty)
        self.meta_updated.config(text=f"Updated at: {row['updated_at']}")
        self.meta_user.config(text=f"Updated by: {row['updated_by']}")
        self.status.config(text=f"Loaded latest for '{entity_id}'.")

    def on_show_history(self):
        if not self.current_entity:
            messagebox.showinfo(APP_TITLE, "Select an ID first.")
            return
        HistoryWindow(self, self.conn, self.current_entity, on_load_version=self._load_version_into_editor)

    def _load_version_into_editor(self, row: sqlite3.Row):
        # Load a past version into the editor (does NOT auto-save)
        self.current_entity = row["entity_id"]
        self.current_loaded_row_id = row["id"]
        self.meta_entity.config(text=f"ID: {row['entity_id']}")
        try:
            pretty = json.dumps(json.loads(row["data_json"]), indent=2, ensure_ascii=False)
        except Exception:
            pretty = row["data_json"]
        self.editor.delete("1.0", tk.END)
        self.editor.insert("1.0", pretty)
        self.meta_updated.config(text=f"Updated at: {row['updated_at']}")
        self.meta_user.config(text=f"Updated by: {row['updated_by']}")
        self.status.config(text=f"Loaded historical row id {row['id']} into editor (not saved). Click 'Save New Version' to create a new version.")
        self.refresh_entity_list(select_id=row["entity_id"])

    def show_current_view(self):
        CurrentViewWindow(self, self.conn)

    def on_export_current(self):
        path = filedialog.asksaveasfilename(
            title="Export Current Snapshot to CSV",
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv")],
            initialfile="current_snapshot.csv",
        )
        if not path:
            return
        try:
            export_current_snapshot_csv(self.conn, Path(path))
            messagebox.showinfo(APP_TITLE, f"Exported current snapshot to:\n{path}")
        except Exception as e:
            messagebox.showerror(APP_TITLE, f"Export failed: {e}")

    def on_export_full(self):
        path = filedialog.asksaveasfilename(
            title="Export Full Audit Log to CSV",
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv")],
            initialfile="full_audit_log.csv",
        )
        if not path:
            return
        try:
            export_full_audit_csv(self.conn, Path(path))
            messagebox.showinfo(APP_TITLE, f"Exported full audit log to:\n{path}")
        except Exception as e:
            messagebox.showerror(APP_TITLE, f"Export failed: {e}")

    def refresh_entity_list(self, select_id: str | None = None):
        query = (self.search_var.get() or "").strip().lower()
        ids = get_all_entity_ids(self.conn)
        if query:
            ids = [x for x in ids if query in x.lower()]
        self.entity_list.delete(0, tk.END)
        for eid in ids:
            self.entity_list.insert(tk.END, eid)
        if select_id and select_id in ids:
            idx = ids.index(select_id)
            self.entity_list.selection_clear(0, tk.END)
            self.entity_list.selection_set(idx)
            self.entity_list.see(idx)

    def on_load_json_file(self):
        if not self.current_entity:
            messagebox.showwarning(APP_TITLE, "Select or create an ID first.")
            return
        path = filedialog.askopenfilename(
            title="Load JSON into Editor",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
        )
        if not path:
            return
        try:
            txt = Path(path).read_text(encoding="utf-8")
            obj = json.loads(txt)
            if not isinstance(obj, dict):
                raise ValueError("Top-level JSON must be an object.")
            pretty = json.dumps(obj, indent=2, ensure_ascii=False)
            self.editor.delete("1.0", tk.END)
            self.editor.insert("1.0", pretty)
            self.status.config(text=f"Loaded JSON from {path} into editor.")
        except Exception as e:
            messagebox.showerror(APP_TITLE, f"Failed to load JSON: {e}")

    def on_save_json_file(self):
        if not self.current_entity:
            messagebox.showwarning(APP_TITLE, "Select or create an ID first.")
            return
        path = filedialog.asksaveasfilename(
            title="Save Editor JSON to File",
            defaultextension=".json",
            filetypes=[("JSON files", "*.json")],
            initialfile=f"{self.current_entity}.json",
        )
        if not path:
            return
        try:
            txt = self.editor.get("1.0", tk.END)
            # Validate JSON
            obj = json.loads(txt)
            if not isinstance(obj, dict):
                raise ValueError("Top-level JSON must be an object.")
            Path(path).write_text(json.dumps(obj, indent=2, ensure_ascii=False), encoding="utf-8")
            self.status.config(text=f"Saved editor JSON to {path}")
        except Exception as e:
            messagebox.showerror(APP_TITLE, f"Failed to save JSON: {e}")


class HistoryWindow(tk.Toplevel):
    def __init__(self, parent: App, conn: sqlite3.Connection, entity_id: str, on_load_version):
        super().__init__(parent)
        self.parent = parent
        self.conn = conn
        self.entity_id = entity_id
        self.on_load_version = on_load_version
        self.title(f"History – {entity_id}")
        self.geometry("800x500")

        columns = ("id", "updated_at", "updated_by")
        self.tree = ttk.Treeview(self, columns=columns, show="headings")
        for c in columns:
            self.tree.heading(c, text=c)
            self.tree.column(c, width=160 if c != "id" else 80, anchor=tk.W)
        self.tree.pack(fill=tk.BOTH, expand=True)

        btns = ttk.Frame(self)
        btns.pack(fill=tk.X)
        ttk.Button(btns, text="Load Selected into Editor", command=self.load_selected).pack(side=tk.LEFT, padx=6, pady=6)
        ttk.Button(btns, text="Close", command=self.destroy).pack(side=tk.RIGHT, padx=6, pady=6)

        self.refresh()

    def refresh(self):
        self.tree.delete(*self.tree.get_children())
        for r in get_history(self.conn, self.entity_id):
            self.tree.insert("", tk.END, values=(r["id"], r["updated_at"], r["updated_by"]))

    def load_selected(self):
        sel = self.tree.selection()
        if not sel:
            return
        iid = sel[0]
        values = self.tree.item(iid, "values")
        row_id = int(values[0])
        cur = self.conn.cursor()
        cur.execute("SELECT * FROM records WHERE id = ?", (row_id,))
        row = cur.fetchone()
        if row:
            self.on_load_version(row)


class CurrentViewWindow(tk.Toplevel):
    def __init__(self, parent: App, conn: sqlite3.Connection):
        super().__init__(parent)
        self.conn = conn
        self.title("Current View – Most Recent Row per ID")
        self.geometry("1000x600")

        # Build dynamic columns from union of keys
        rows = get_latest_snapshot(self.conn)
        field_keys = _collect_keys(rows)
        columns = ["entity_id", "updated_at", "updated_by"] + field_keys

        self.tree = ttk.Treeview(self, columns=columns, show="headings")
        for c in columns:
            self.tree.heading(c, text=c)
            width = 140
            if c in ("entity_id", "updated_at", "updated_by"):
                width = 160
            self.tree.column(c, width=width, anchor=tk.W)
        self.tree.pack(fill=tk.BOTH, expand=True)

        yscroll = ttk.Scrollbar(self, orient=tk.VERTICAL, command=self.tree.yview)
        self.tree.configure(yscroll=yscroll.set)
        yscroll.pack(side=tk.RIGHT, fill=tk.Y)

        self.refresh()

    def refresh(self):
        self.tree.delete(*self.tree.get_children())
        rows = get_latest_snapshot(self.conn)
        field_keys = _collect_keys(rows)
        for r in rows:
            try:
                data = json.loads(r["data_json"]) or {}
            except Exception:
                data = {}
            vals = [r["entity_id"], r["updated_at"], r["updated_by"]] + [data.get(k, "") for k in field_keys]
            self.tree.insert("", tk.END, values=vals)


# ---------------------------
# Main
# ---------------------------

def main():
    db_path = get_db_path()
    conn = connect_db(db_path)
    init_db(conn)

    # Optional: seed with an example row if DB empty, to show how it works
    #cur = conn.cursor()
    #cur.execute("SELECT COUNT(*) FROM records")
    #if cur.fetchone()[0] == 0:
    #    insert_new_version(conn, "EXAMPLE-001", {"name": "Sample", "qty": 10, "status": "new"})

    app = App(conn)
    app.mainloop()


if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"Fatal error: {e}", file=sys.stderr)
        sys.exit(1)
